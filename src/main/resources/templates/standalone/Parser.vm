
#set($intellij = false)
#set($badCharacterElementType = "IElementType.BAD_CHARACTER")

#define($imports)
import ${cmImplPackageName}.IElementType;
#end

#define($implements)
#end

#define($declarations)

    private void beginSpeculativeTokenConsumption() {
        tokenMarker = tokenPointer;
    }

    private void endSpeculativeTokenConsumption() {
        tokenPointer = tokenMarker;
    }

    private ASTNode getToken() {
        return tokenPointer >= tokens.length ? null : tokens[tokenPointer];
    }

    private IElementType getTokenType() {
        return tokenPointer >= tokens.length ? null : tokens[tokenPointer].getElementType();
    }

    private boolean isAtEof() {
        return tokenPointer >= tokens.length;
    }

    private void nextToken() {
        if (tokenPointer < tokens.length) {
            tokenPointer++;
        }
    }

    private void reportErrorForCurrentToken(String errorMessage) {
        // TODO
    }

	private ASTNode buildAst(Object what, IElementType parentElementType) {
	    if (what == null) {
	        ASTNode node = getToken();
            nextToken();
            return node;
	    } else if (what instanceof Object[]) {


        /*
        TODO handle mergeable sublists here


        InternalPsiUtil.foreachChild(this, child -> {
            #if($intellij)
                if (elementTypes.contains(child.getNode().getElementType())) {
                    consumer.accept(elementClass.cast(child));
                    return;
                }
            #else
                IElementType childType = child.getNode().getElementType();
                for (IElementType elementType : elementTypes) {
                    if (childType == elementType) {
                        consumer.accept(elementClass.cast(child));
                        return;
                    }
                }
            #end
            if (child instanceof CmListImpl<?> && child.getNode().getElementType() == getNode().getElementType()) {
                CmListImpl<?> typedChild = (CmListImpl<?>)child;
                typedChild.cast(elementClass).foreach(consumer);
            }
        });

        */




			Object[] reduction = (Object[]) what;
			IElementType elementType;
			boolean publicNode;
			if (reduction[0] instanceof ListNodeGenerationWrapper) {
				ListNodeGenerationWrapper listNodeGenerationWrapper = (ListNodeGenerationWrapper)reduction[0];
				elementType = listNodeGenerationWrapper.elementType;
				publicNode = (parentElementType == null || elementType != parentElementType);
			} else {
				elementType = (IElementType)reduction[0];
				publicNode = true;
			}
			List<ASTNode> childNodes = new ArrayList<>();
			for (int i = 1; i < reduction.length; i++) {
				childNodes.add(buildAst(reduction[i], elementType));
			}
			return new ASTNode(elementType, childNodes.toArray(new ASTNode[childNodes.size()]), publicNode);
		} else if (what instanceof List<?>) {
			// an object list has the same meaning as an object array (needed for error symbols)
			return buildAst(((List<?>)what).toArray(), parentElementType);
		} else if (what instanceof ErrorLocationIndicator) {
		    ErrorLocationIndicator errorLocationIndicator = (ErrorLocationIndicator)what;
			reportErrorForCurrentToken("expected one of: " + STATE_INPUT_EXPECTATION[errorLocationIndicator.state]);
			return null;
		} else if (what instanceof UnrecoverableSyntaxException) {
            reportErrorForCurrentToken(((UnrecoverableSyntaxException)what).getMessage());
            tokenPointer = tokens.length;
		}
	}

#end

#parse("templates/include/Parser.vm")

