
%terminals {
    KW_TERMINALS, KW_NONTERMINALS, KW_PRECEDENCE, KW_LEFT, KW_RIGHT, KW_NONASSOC, KW_START, KW_RESOLVE, KW_SHIFT, KW_REDUCE,
    OPENING_CURLY_BRACE, CLOSING_CURLY_BRACE, OPENING_PARENTHESIS, CLOSING_PARENTHESIS,
    COMMA, SEMICOLON, COLON, EXPANDS_TO, QUESTION_MARK, ASTERISK, PLUS, BAR,
	IDENTIFIER,
	BLOCK_COMMENT, LINE_COMMENT // never passed to the parser
}

%nonterminals {
    grammar, precedenceDeclaration,
	production, rightHandSide, expression, resolveDeclaration,
	nonemptyIdentifierList
}

%precedence {
	%left BAR;
	%nonassoc QUESTION_MARK, ASTERISK, PLUS;
}

%start grammar;


//
// grammar
//

grammar ::=
	KW_TERMINALS OPENING_CURLY_BRACE nonemptyIdentifierList CLOSING_CURLY_BRACE
	KW_NONTERMINALS OPENING_CURLY_BRACE nonemptyIdentifierList CLOSING_CURLY_BRACE
	(KW_PRECEDENCE OPENING_CURLY_BRACE precedenceDeclaration* CLOSING_CURLY_BRACE)?
	KW_START IDENTIFIER:startSymbolName SEMICOLON
	production+
	;

precedenceDeclaration ::=
    (KW_LEFT | KW_RIGHT | KW_NONASSOC) nonemptyIdentifierList SEMICOLON
    ;


//
// productions
//

production ::=
	IDENTIFIER (COLON IDENTIFIER)? COLON_COLON_EQUALS rightHandSide SEMICOLON
	IDENTIFIER COLON_COLON_EQUALS OPENING_CURLY_BRACE ((IDENTIFIER COLON_COLON_EQUALS)? rightHandSide SEMICOLON)* CLOSING_CURLY_BRACE
	| error SEMICOLON
	;

rightHandSide ::=
    expression
    | expression KW_PRECEDENCE IDENTIFIER
    | expression KW_RESOLVE OPENING_CURLY_BRACE resolveDeclaration* CLOSING_CURLY_BRACE
    ;

resolveDeclaration ::=
    (KW_SHIFT | KW_REDUCE) nonemptyIdentifierList SEMICOLON

// TODO ambiguous; resolve using %resolve declarations
expression ::=
    IDENTIFIER
    | expression expression
    | expression BAR expression
    | expression ASTERISK
    | expression PLUS
    | expression QUESTION_MARK
    | OPENING_PARENTHESIS expression+ CLOSING_PARENTHESIS
    | expression COLON IDENTIFIER
	;

//
// helpers
//

nonemptyIdentifierList ::=
	IDENTIFIER (COMMA IDENTIFIER)*
	;
