
%terminals {
    KW_TERMINALS, KW_NONTERMINALS, KW_PRECEDENCE, KW_LEFT, KW_RIGHT, KW_NONASSOC, KW_START, KW_RESOLVE, KW_SHIFT, KW_REDUCE, KW_EOF, KW_ERROR,
    OPENING_CURLY_BRACE, CLOSING_CURLY_BRACE, OPENING_PARENTHESIS, CLOSING_PARENTHESIS,
    COMMA, SEMICOLON, COLON, EXPANDS_TO, QUESTION_MARK, ASTERISK, PLUS, BAR,
	IDENTIFIER,
	BLOCK_COMMENT, LINE_COMMENT // never passed to the parser
}

%nonterminals {
    grammar, precedenceDeclaration,
	production, rightHandSide, expression, resolveDeclaration, resolveDeclarationSymbol,
	nonemptyIdentifierList
}

%start grammar;


//
// grammar
//

grammar ::=
	KW_TERMINALS OPENING_CURLY_BRACE nonemptyIdentifierList:terminals CLOSING_CURLY_BRACE
	KW_NONTERMINALS OPENING_CURLY_BRACE nonemptyIdentifierList:nonterminals CLOSING_CURLY_BRACE
	(KW_PRECEDENCE OPENING_CURLY_BRACE precedenceDeclaration*:precedenceDeclarations CLOSING_CURLY_BRACE)?:precedenceTable
	KW_START IDENTIFIER:startSymbolName SEMICOLON
	production+:productions
	;

precedenceDeclaration ::= (KW_LEFT:left | KW_RIGHT:right | KW_NONASSOC:nonassoc):associativity nonemptyIdentifierList:terminals SEMICOLON;


//
// productions
//

production ::= {
	singleUnnamed ::= IDENTIFIER:nonterminalName EXPANDS_TO rightHandSide:rightHandSide SEMICOLON;
	singleNamed ::= IDENTIFIER:nonterminalName COLON IDENTIFIER:alternativeName EXPANDS_TO rightHandSide:rightHandSide SEMICOLON;
	multi ::= IDENTIFIER:nonterminalName EXPANDS_TO OPENING_CURLY_BRACE
		((rightHandSide:rightHandSide SEMICOLON):unnamed | (IDENTIFIER:alternativeName EXPANDS_TO rightHandSide:rightHandSide SEMICOLON):named)*:alternatives
		CLOSING_CURLY_BRACE;
	error ::= %error SEMICOLON;
}

rightHandSide ::= {
    withoutResolver ::= expression:expression;
    withPrecedenceResolver ::= expression:expression KW_PRECEDENCE IDENTIFIER:precedenceDefiningTerminal;
    withExplicitResolver ::= expression:expression KW_RESOLVE OPENING_CURLY_BRACE resolveDeclaration*:resolveDeclarations CLOSING_CURLY_BRACE;
}

resolveDeclaration ::= (KW_SHIFT:shift | KW_REDUCE:reduce):action resolveDeclarationSymbol:firstSymbol (COMMA resolveDeclarationSymbol:symbol)*:additionalSymbols SEMICOLON;

resolveDeclarationSymbol ::= {
    identifier ::= IDENTIFIER:symbol;
    eof ::= KW_EOF;
}

expression ::= {
    identifier ::= IDENTIFIER:identifier;
    error ::= KW_ERROR;
    sequence ::= expression:left expression:right %resolve {
		%shift QUESTION_MARK, ASTERISK, PLUS, COLON;
		%reduce OPENING_PARENTHESIS, IDENTIFIER, KW_ERROR, BAR;
    };
    or ::= expression:left BAR expression:right %resolve {
		%shift QUESTION_MARK, ASTERISK, PLUS, COLON, OPENING_PARENTHESIS, IDENTIFIER, KW_ERROR;
		%reduce BAR;
    };
    zeroOrMore ::= expression:operand ASTERISK;
    oneOrMore ::= expression:operand PLUS;
    optional ::= expression:operand QUESTION_MARK;
    parenthesized ::= OPENING_PARENTHESIS expression:inner CLOSING_PARENTHESIS;
    named ::= expression:expression COLON IDENTIFIER:expressionName;
}

//
// helpers
//

nonemptyIdentifierList ::= IDENTIFIER:firstIdentifier (COMMA IDENTIFIER:identifier)*:moreIdentifiers;
