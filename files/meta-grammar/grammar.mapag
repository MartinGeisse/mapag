
%terminals {

	// grammar keywords
    KW_TERMINALS, KW_PRECEDENCE, KW_LEFT, KW_RIGHT, KW_NONASSOC, KW_START,

    // production keywords
    KW_RESOLVE, KW_SHIFT, KW_REDUCE, KW_EOF, KW_ERROR, KW_REDUCE_ON_ERROR,

	// parentheses, braces and brackets
    OPENING_CURLY_BRACE, CLOSING_CURLY_BRACE, OPENING_PARENTHESIS, CLOSING_PARENTHESIS,

    // punctuation
    COMMA, SEMICOLON, COLON, EXPANDS_TO, QUESTION_MARK, ASTERISK, PLUS, BAR,

    // identifiers
	IDENTIFIER,

	// comments (never passed to the parser, but unlike whitespace we need them in the symbols holder class because
	// IntelliJ doesn't define a generic IElementType for comments)
	BLOCK_COMMENT, LINE_COMMENT

}

%start grammar;


//
// grammar
//

grammar ::=
	KW_TERMINALS OPENING_CURLY_BRACE nonemptyIdentifierList:terminals CLOSING_CURLY_BRACE
	(KW_PRECEDENCE OPENING_CURLY_BRACE precedenceDeclaration*:precedenceDeclarations CLOSING_CURLY_BRACE)?:precedenceTable
	KW_START IDENTIFIER:startSymbolName SEMICOLON
	production+:productions
	;

precedenceDeclaration ::= (KW_LEFT:left | KW_RIGHT:right | KW_NONASSOC:nonassoc):associativity nonemptyIdentifierList:terminals SEMICOLON;


//
// productions
//

production ::= {
	singleUnnamed ::= IDENTIFIER:nonterminalName EXPANDS_TO rightHandSide:rightHandSide SEMICOLON;
	singleNamed ::= IDENTIFIER:nonterminalName COLON IDENTIFIER:alternativeName EXPANDS_TO rightHandSide:rightHandSide SEMICOLON;
	multi ::= IDENTIFIER:nonterminalName EXPANDS_TO OPENING_CURLY_BRACE
		((rightHandSide:rightHandSide SEMICOLON):unnamed | (IDENTIFIER:alternativeName EXPANDS_TO rightHandSide:rightHandSide SEMICOLON):named)*:alternatives
		CLOSING_CURLY_BRACE;
	error ::= %error SEMICOLON;
}

rightHandSide ::= expression:expression rightHandSideAttribute*:attributes;

rightHandSideAttribute ::= {
	precedence ::= KW_PRECEDENCE IDENTIFIER:precedenceDefiningTerminal;
	resolveBlock ::= KW_RESOLVE OPENING_CURLY_BRACE resolveDeclaration*:resolveDeclarations CLOSING_CURLY_BRACE;
	reduceOnError ::= KW_REDUCE_ON_ERROR;
}

resolveDeclaration ::= (KW_SHIFT:shift | KW_REDUCE:reduce):action resolveDeclarationSymbol:firstSymbol (COMMA resolveDeclarationSymbol:symbol)*:additionalSymbols SEMICOLON;

resolveDeclarationSymbol ::= {
    identifier ::= IDENTIFIER:symbol;
    eof ::= KW_EOF;
}

expression ::= {
    identifier ::= IDENTIFIER:identifier;
    error ::= KW_ERROR;
    eof ::= KW_EOF;
    sequence ::= expression:left expression:right %resolve {
		%shift QUESTION_MARK, ASTERISK, PLUS, COLON;
		%reduce OPENING_PARENTHESIS, IDENTIFIER, KW_ERROR, KW_EOF, BAR;
    };
    or ::= expression:left BAR expression:right %resolve {
		%shift QUESTION_MARK, ASTERISK, PLUS, COLON, OPENING_PARENTHESIS, IDENTIFIER, KW_ERROR, KW_EOF;
		%reduce BAR;
    };
    zeroOrMore ::= expression:operand ASTERISK;
    oneOrMore ::= expression:operand PLUS;
    optional ::= expression:operand QUESTION_MARK;
    parenthesized ::= OPENING_PARENTHESIS expression:inner CLOSING_PARENTHESIS;
    named ::= expression:expression COLON IDENTIFIER:expressionName;
}

//
// helpers
//

nonemptyIdentifierList ::= IDENTIFIER:firstIdentifier (COMMA IDENTIFIER:identifier)*:moreIdentifiers;
