
%package name.martingeisse.mapag.input;
%class MapagGeneratedMapagParser;

%terminals {
    KW_TERMINALS, KW_NONTERMINALS, KW_PRECEDENCE, KW_LEFT, KW_RIGHT, KW_NONASSOC, KW_START,
    OPENING_CURLY_BRACE, CLOSING_CURLY_BRACE, OPENING_PARENTHESIS, CLOSING_PARENTHESIS,
    DOT, COMMA, SEMICOLON, COLON, EXPANDS_TO, QUESTION_MARK, ASTERISK, PLUS, BAR,
	IDENTIFIER
}

%nonterminals {
    grammar, precedenceDeclaration,
	production, alternative, toplevelExpression, nestedExpression,
	nonemptyIdentifierList
}

%start grammar;


//
// grammar
//

grammar ::=
	KW_TERMINALS OPENING_CURLY_BRACE nonemptyIdentifierList CLOSING_CURLY_BRACE
	KW_NONTERMINALS OPENING_CURLY_BRACE nonemptyIdentifierList CLOSING_CURLY_BRACE
	(KW_PRECEDENCE OPENING_CURLY_BRACE precedenceDeclaration* CLOSING_CURLY_BRACE)?
	KW_START IDENTIFIER:startSymbolName SEMICOLON
	production+
	;

precedenceDeclaration ::=
    (KW_LEFT | KW_RIGHT | KW_NONASSOC) nonemptyIdentifierList SEMICOLON
    ;


//
// productions
//

// Note: The way toplevelExpression and nestedExpression is used here seems to be unnecessarily complex -- it looks
// like operator precedence done "the old way". AFAIK it's still the best solution since this is a special case
// due to the interaction of top-level BAR-ing, nested BAR-ing and precedence annotations. If precedence annotations
// were possible at any nesting level then we'd just make them another expression type and no distinction between
// top-level and nested BAR-ing were necessary -- but unfortunately that's not the case.

production ::=
	IDENTIFIER COLON_COLON_EQUALS alternative (BAR alternative)* SEMICOLON
	| error SEMICOLON
	;

alternative ::=
    toplevelExpression+ (KW_PRECEDENCE IDENTIFIER)?
    ;

toplevelExpression ::=
   	IDENTIFIER (COLON IDENTIFIER)?
    | toplevelExpression ASTERISK
    | toplevelExpression PLUS
    | toplevelExpression QUESTION_MARK
    | OPENING_PARENTHESIS nestedExpression+ CLOSING_PARENTHESIS (COLON IDENTIFIER)?
    ;

nestedExpression ::=
    IDENTIFIER (COLON IDENTIFIER)?
    | nestedExpression BAR toplevelExpression
    | nestedExpression ASTERISK
    | nestedExpression PLUS
    | nestedExpression QUESTION_MARK
    | OPENING_PARENTHESIS nestedExpression+ CLOSING_PARENTHESIS (COLON IDENTIFIER)?
	;


//
// helpers
//

nonemptyIdentifierList ::=
	IDENTIFIER (COMMA IDENTIFIER)*
	;
