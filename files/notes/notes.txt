
PsiBuilder: This has been built for LL parsing. It is not compatible with LR parsing in the usual way.

Workaround: Mark at start. Use psiBuilder.advanceLexer() to read all tokens and feed them to the parser. Do not build
	an AST but rather record all shift and reduce steps (might have to use a tree for recording, but that's not an
	AST, rather it's very similar to the concrete derivation tree). rollbackTo() the marker at start, then execute the
	recorded steps and set the actual markers.


Precedence table vs. nested expressions:
- introduce ad-hoc nonterminals for nested repetition (not needed for toplevel repetition)
    -> or modify SM generation, but this has the same effect. More complex code but better error reporting for
        problems with the grammar. TODO correct?
- TODO: question mark
- introduce ad-hoc nonterminals for nested alternatives if that expression directly (without consulting the rules for
    contained nonterminals) contains only terminals without assigned precedence.
- raise nested alternatives that directly contain terminals with assigned precedence
    --> future: if this produces a too large grammar, group contained terminals by precedence and introduce per-group
    nonterminals with assigned precedence. Requires a minor change in that nonterminals can have an assigned precedence,
    but since shifting nonterminals is always deterministic, this only affects the implicitly assigned precedence
    of a rule -- it's no longer "last terminal" but "last terminal unless a later nonterminal has assigned precedence".
    --> may consider further clarification.

------------------------------------------------------------

(1) Sample grammar for question mark: arithmetic expressions with debug output -- debug indicator written after operator:

start: E
E -> 1
E -> E + d? E
E -> E * d? E

--> Messes up automatic precedence assignment. Can be fixed by adding precedence annotations to the rules.

------------------------------------------------------------

(2) Sample grammar for question mark: arithmetic expressions with debug output -- debug indicator written before operator:

start: E
E -> 1
E -> E d? + E
E -> E d? * E

--> Messes up precedence because we need a two-token lookahead to find the operator symbol. This isn't a good example
for either case because we need an LR(2) parser to unterstand it.

------------------------------------------------------------

(3) Sample grammar for question mark (or repetition) in which the optional part (or repeated part) has an embedded
precedence. This is the really interesting case.

Nested alternatives really don't matter either, except for finding the precedence of a rule! This is the only case
where an ad-hoc nonterminal weakens the grammar. This is also exactly what happens when grouping the operators for
expressions in a nested alternative.

Do we want automatic handling of such groups? e.g.

    E -> E (+ | - | * | /) E

    transformed to

    E -> E (+ | -) E    %precedence +-
    E -> E (* | /) E    %precedence */

    or actually (normalized form)

    E -> (E (+ | -) E) | (E (* | /) E)

step1: split precedence-hiding nested alternative
step2: extract ad-hoc nonterminals
step3: determine toplevel alternatives and their precedences

-------

Discussion: should a rule like [[ E -> E (+ | - | * | /) E ]] be split automatically or not?
- pro: more compact grammar, less annoying manual work
- con: automatic transformations make errors harder to track down
- con: is a special case optimization for expressions -- little use elsewhere

The same is less severe for ad-hoc nonterminals because those can be named according to their content and are thus
easier to track down.

-------




