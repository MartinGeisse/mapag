package $packageName;

import com.intellij.lang.ASTNode;
import com.intellij.lang.LightPsiParser;
import com.intellij.lang.PsiBuilder;
import com.intellij.lang.PsiParser;
import com.intellij.psi.TokenType;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiNamedElement;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.impl.source.tree.LeafPsiElement;
import com.intellij.extapi.psi.ASTWrapperPsiElement;
import org.jetbrains.annotations.NotNull;
#if($dynamicallyNamedImplementation || $isSafeDeletableAbstract || $isSafeDeletableImplementation)
	import com.intellij.util.IncorrectOperationException;
#end
#if($isReference)
	import com.intellij.psi.PsiReference;
#end

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.common.collect.ImmutableList;

public $classModifiers class $className extends $superclass #if($dynamicallyNamedAbstract) implements PsiNamedElement #end {

    public $className(@NotNull ASTNode node) {
        super(node);
    }

    #foreach($nodeGetter in $nodeGetters)
    public $nodeGetter.nodeType ${nodeGetter.getterName}() {
            return ($nodeGetter.nodeType)InternalPsiUtil.getChild(this, $nodeGetter.childIndex);
        }
    #end

	#if($dynamicallyNamedImplementation)

		public String getName() {
			return ${psiUtilClass}.getName(this);
		}

		public PsiElement setName(String newName) throws IncorrectOperationException {
			return ${psiUtilClass}.setName(this, newName);
		}

	#end

	#if($isReference)
		public PsiReference getReference() {
			return ${psiUtilClass}.getReference(this);
		}
	#end

	#if($isSafeDeletableAbstract)
		public void superclassDelete() throws IncorrectOperationException {
			super.delete();
		}
	#end

	#if($isSafeDeletableImplementation)
		public void delete() throws IncorrectOperationException {
			${psiUtilClass}.delete(this);
		}
	#end

}
