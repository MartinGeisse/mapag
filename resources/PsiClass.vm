package $packageName;

import com.intellij.lang.ASTNode;
import com.intellij.lang.LightPsiParser;
import com.intellij.lang.PsiBuilder;
import com.intellij.lang.PsiParser;
import com.intellij.psi.TokenType;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiNamedElement;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.impl.source.tree.LeafPsiElement;
import com.intellij.extapi.psi.ASTWrapperPsiElement;
import org.jetbrains.annotations.NotNull;
#if($dynamicallyNamedImplementation || $isSafeDeletableAbstract || $isSafeDeletableImplementation)
	import com.intellij.util.IncorrectOperationException;
#end
#if($isReference)
	import com.intellij.psi.PsiReference;
#end

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.common.collect.ImmutableList;

public $classModifiers class $className extends $superclass #if($dynamicallyNamedAbstract) implements PsiNamedElement #end {

    public $className(@NotNull ASTNode node) {
        super(node);
    }

    #foreach($nodeGetter in $nodeGetters)
    public $nodeGetter.nodeType ${nodeGetter.getterName}() {
            return ($nodeGetter.nodeType)InternalPsiUtil.getChild(this, $nodeGetter.childIndex);
        }
    #end


    ##
    ## optionals
    ##

    #if ($isOptionalAbstract)

        public abstract $operandType $optionalOperandGetterName();

    #elseif ($isOptionalAbsentCase)

        public $operandType $optionalOperandGetterName() {
            return null;
        }

    #elseif ($isOptionalPresentCase)

        ## the normal getter will override the abstract method form the parent class

    #end


    ##
    ## repetitions
    ##

    #if ($isRepetitionAbstract)

        public abstract ImmutableList<$operandType> getAll();

        public abstract void addAllTo(List<$operandType> list);

        public abstract void addAllTo(ImmutableList.Builder<$operandType> builder);

    #elseif ($isRepetitionBaseCase)

        public ImmutableList<$operandType> getAll() {
            #if ($isZeroBasedRepetition)
                return ImmutableList.of();
            #else
                return ImmutableList.of(getElement());
            #end
        }

        public void addAllTo(List<$operandType> list) {
            #if (!$isZeroBasedRepetition)
                list.add(getElement());
            #end
        }

        public void addAllTo(ImmutableList.Builder<$operandType> builder) {
            #if (!$isZeroBasedRepetition)
                builder.add(getElement());
            #end
        }

    #elseif ($isRepetitionNextCase)

        public ImmutableList<$operandType> getAll() {
            ImmutableList.Builder<$operandType> builder = ImmutableList.builder();
            addAllTo(builder);
            return builder.build();
        }

        public void addAllTo(List<$operandType> list) {
            getPrevious().addAllTo(list);
            list.add(getElement());
        }

        public void addAllTo(ImmutableList.Builder<$operandType> builder) {
            getPrevious().addAllTo(builder);
            builder.add(getElement());
        }

    #end

	#if($dynamicallyNamedImplementation)

		public String getName() {
			return ${psiUtilClass}.getName(this);
		}

		public PsiElement setName(String newName) throws IncorrectOperationException {
			return ${psiUtilClass}.setName(this, newName);
		}

	#end

	#if($isReference)
		public PsiReference getReference() {
			return ${psiUtilClass}.getReference(this);
		}
	#end

	#if($isSafeDeletableAbstract)
		public void superclassDelete() throws IncorrectOperationException {
			super.delete();
		}
	#end

	#if($isSafeDeletableImplementation)
		public void delete() throws IncorrectOperationException {
			${psiUtilClass}.delete(this);
		}
	#end

}
